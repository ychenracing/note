# 一 事务的隔离级别
## 1.1 读现象
“读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。先了解它们有助于理解各隔离级别的含义。

### 1.1.1 脏读
脏读发生的前提是一个事务能读到其他事务中未提交的操作。**脏读重点关注的是“其他事务未提交的数据”，**如果在读取到这样的数据后，那个事务进行了回滚，我们就相当于读到了数据库中不再存在的数据（也就是“脏数据”）。

### 1.1.2 不可重复读
**不可重复读重点关注的是修改**，指的是同一批数据，本次事务读取了两次，前后读取的值不一样。针对的是其他事务提交前后，本事务读取数据本身的对比。

```sql
SELECT id, name FROM test;    =>   (1,"n1"), (2, "n2"), (5, "n5")
SELECT id, name FROM test;    =>   (1, "n1"), (2, "David"), (5, "n5")
```

注意，返回的仍然是主键为 1,2,5 的数据，但 id=2 的那行数据的 name 变了。这种情况的原因是：在第二次 SELECT 前，其它事务对此条目进行了 UPDATE，并进行了提交。

### 1.1.3 幻读
**幻读重点关注的是“新增或者删除”**，指读取了两次，前后读取到的不是同一批数据。针对的是其他事务提交前后，本事务读取数据条数的对比。

```sql
SELECT id FROM test;    =>  1,2,5
SELECT id FROM test;    =>  1,2,5,6 
```

出现这种请况一般是因为在第二次 SELECT 执行前，有其他事务进行了 INSERT 或 DELETE 操作，并进行了提交。

**这三种读现象是并列、互不相关的，例如在某个隔离等级中出现了“不可重复读”，并不意味着就一定也能出现“幻读”。**

## 1.2 隔离级别

SQL 标准中定义了4个隔离级别，一般来说，隔离级别越高，会出现的“读现象”就越少。  但这只是一个规范。每种隔离级别在不同的数据库中有不同的特性和实现方式。  这4个级别为：

### 1.2.1 Read uncommitted（读未提交）
这是最宽松的级别。其他事务对数据进行的任意更改就算没提交，也会立刻反应到当前事务中。所有读现象都可能出现在这个级别中。因为太宽松了，这个级别很少被用到。

### 1.2.2 Read committed（读已提交）
此级别中，其他事务对数据进行的更改只要一提交，就可以在当前事务中读取到。**避免了“脏读”现象，会出现“不可重复读”和“幻读”。**

### 1.2.3 Repeatable reads （可重复读）
比可串行化稍宽松一点的级别。根据定义，此级别中不会出现“不可重复读”的现象，也就是其他事务对某行数据的更改无论提交没提交，都不会反应到当前事务中。
**但是会出现“幻读”，也就是其他事务中插入的新数据，允许出现在当前事务里。**

### 1.2.4 Serializable （串行化）
简单的说，此级别下运行的事务是完全隔离的，不会受到其他事务的干扰（因此不会出现任何“读现象”）。其他事务中对数据进行的更新，在此事务中不可见（但可能导致此事务执行失败）。

从技术上来说，此级别下的事务必须以串行的方式被执行，或者至少是串行等价的，否则会以报错的形式结束并回滚。“串行”也就是一个接一个的运行，这种情况下一个事务当然不会被其他事务干扰。“串行等价”的意思就是：两个/多个事务就算同时运行（并行），得到的结果也和一个接一个的运行（串行）一样。所以对于这些事务，即使同时运行也没关系。

这是一个最理想的级别，我们可以认为在这个级别下不会因事务间的冲突而破坏数据一致性。但相对的，性能也最低，所以不常用（也因此我实际并没有在此级别下运行过 SQL 语句，不清楚它到底有多强大）。

**MySQL 的默认事务级别是 `Repeatable read`可重复读**

MySQL默认使用的事务隔离级别是可重复度，但是怎么避免“幻读”的呢？

MySQL使用了“行锁”和“间隙锁”来避免幻读。默认情况下，MySQL的InnoDB存储引擎在可重复读隔离级别下，会以Next-Key Lock（后码锁，即行锁和间隙锁的组合）的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对**索引记录**加上行锁（Record Lock），再对**索引记录两边**的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。Gap Lock在InnoDB的唯一作用就是防止其他事务的插入操作，以此防止幻读的发生。行锁锁定的是索引记录，而不是行数据，也就是说锁定的是key。间隙锁（Gap Lock）锁定的是索引记录的两边，而不是行数据，也就是说锁定的也是key。

# 二 范式
## 2.1 第一范式
<font color="red">**字段不可分**</font>  
**定义**：如果关系R中所有属性的值域都是单纯域，那么关系模式R是第一范式的。  

那么符合第一模式的特点就有

1. 有主关键字
2. 主键不能为空
3. 主键不能重复
4. 字段不可以再分

例如：

StudyNo   |   Name   |   Sex   |   Contact
----------|----------|---------|----------
20040901  |   john   |   Male  |Email:kkkk@ee.net,phone:222456|
20040901  |   mary   |  famale |email:kkk@fff.net,phone:123455|

以上的表就不符合第一范式：主键重复(实际中数据库不允许重复的)，而且Contact字段可以再分

所以变更为正确的是

|  StudyNo  |  Name  |  Sex  |  Email  |  Phone  |
|-----------|--------|-------|---------|---------|
|  20040901 |  john  |Male |kkkk@ee.net|  222456 |
|  20040902 |  mary  |famale|kkk@fff.net| 123455 |

## 2.2 第二范式
<font color="red">**不能有（一个或多个）非主键列部分依赖于主键的情况**</font>  
**定义**：如果关系模式R是第一范式的，而且关系中每一个非主属性不部分依赖于主键，称R是第二范式的。

所以第二范式的主要任务就是：满足第一范式的前提下，消除部分函数依赖。

|StudyNo|Name|Sex|Email|Phone|ClassNo|ClassAddress|
|-------|----|---|-----|-----|-------|------------|
| 01 | john | Male |kkkk@ee.net|222456|200401|A楼2|
| 01 | mary |famale|kkk@fff.net|123455|200402|A楼3|

这个表完全满足于第一范式，主键由StudyNo和ClassNo组成，这样才能定位到指定行。但是，ClassAddress部分依赖于关键字( `ClassNo → ClassAddress` )，所以要变为两个表。

### 表一
|StudyNo|Name|Sex|Email|Phone|ClassNo|
|-------|----|---|-----|-----|-------|
|01|john|Male|kkkk@ee.net|222456|200401|
|01|mary|famale|kkk@fff.net|123455|200402|

### 表二
|ClassNo|ClassAddress|
|-------|------------|
|200401|A楼2|
|200402|A楼3|

## 第三范式
<font color="red">**不能有（一个或多个）非主键列传递依赖于主键的情况**</font>  
**定义**：不存在非主属性对码的传递性依赖以及部分性依赖。

|StudyNo|Name|Sex|Email|bounsLevel|bouns|
|-------|----|---|-----|----------|-----|
|20040901|john|Male|kkkk@ee.net|优秀|$1000|
|20040902|mary|famale|kkk@fff.net|良|$600|

现在，主键是StudyNo，主键只有单个字段，显然符合第二范式，但是bounsLevel和bouns存在传递依赖。

更改为：

|StudyNo|Name|Sex|Email|bounsNo|
|-------|----|---|-----|--------|
|20040901|john|Male|kkkk@ee.net|1|
|20040902|mary|famale|kkk@fff.net|2|

|bounsNo|bounsLevel|bouns|
|-------|----------|-----|
|1|优秀|$1000|
|2|良|$600|

这里我比较喜欢用bounsNo作为主键，基于两个原因

1. 不要用字符作为主键。可能有人说：如果我的等级一开始就用数值就代替呢？

2. 但是如果等级名称更改了，不叫 1，2 ，3或优、良，这样就可以方便更改，所以我一般优先使用与业务无关的字段作为关键字。

一般满足前三个范式就可以避免数据冗余。
